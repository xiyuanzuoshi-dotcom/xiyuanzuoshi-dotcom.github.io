<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ビーチフラッグバトル ステップ2</title>
<style>
html,body{height:100%;margin:0;background:#012;color:#fff;font-family:sans-serif;}
#game{display:block;margin:0 auto;background:radial-gradient(circle at center, #034 0%, #001 80%);}
#hud{position:fixed;left:12px;top:12px;font-size:18px;}
#overlay{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,0.6);color:white;z-index:10;visibility:hidden;}
#overlay.visible{visibility:visible;}
button{padding:10px 18px;border-radius:8px;border:0;background:#06f;color:white;font-weight:700;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">
  <div id="scoreText">プレイヤー:0　敵:0</div>
  <div id="stateText">矢印キーで操作！先に5本フラッグを取れ！</div>
</div>
<div id="overlay">
  <div id="resultText" style="font-size:32px;font-weight:800;"></div>
  <button id="retryBtn">リトライ</button>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const center={x:0,y:0};
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;center.x=canvas.width/2;center.y=canvas.height/2;}
window.addEventListener("resize",resize);resize();

const keys={};
window.addEventListener("keydown",e=>keys[e.key]=true);
window.addEventListener("keyup",e=>keys[e.key]=false);

const scoreText=document.getElementById("scoreText");
const stateText=document.getElementById("stateText");
const overlay=document.getElementById("overlay");
const resultText=document.getElementById("resultText");
const retryBtn=document.getElementById("retryBtn");
retryBtn.onclick=()=>{resetGame();start();overlay.classList.remove("visible");};

let player,enemy,flag,item;
let walls=[];
let running=true;
const MAX_SCORE=5;
let rafId=null;
let itemTimer=0,wallTimer=0;

function randRange(a,b){return a+Math.random()*(b-a);}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function spawnFlag(){const ang=Math.random()*Math.PI*2;const r=randRange(100,Math.min(canvas.width,canvas.height)/3);return{x:center.x+Math.cos(ang)*r,y:center.y+Math.sin(ang)*r};}
function spawnItem(){const ang=Math.random()*Math.PI*2;const r=randRange(80,Math.min(canvas.width,canvas.height)/3.2);return{x:center.x+Math.cos(ang)*r,y:center.y+Math.sin(ang)*r,radius:12,active:true};}
function spawnWall(){const ang=Math.random()*Math.PI*2;const r=randRange(60,Math.min(canvas.width,canvas.height)/2.6);return{x:center.x+Math.cos(ang)*r,y:center.y+Math.sin(ang)*r,radius:randRange(40,70),active:true,ttl:Math.floor(randRange(180,360))};}

function resetGame(){
  player={x:center.x+120,y:center.y,vx:0,vy:0,r:16,color:"white",score:0,inv:false,invT:0};
  enemy={x:center.x-120,y:center.y,vx:0,vy:0,r:16,color:"red",score:0,aiT:0,inv:false,invT:0};
  flag=spawnFlag();
  item=null;
  walls=[];
  running=true;
  itemTimer=240;wallTimer=300;
  scoreText.textContent="プレイヤー:0　敵:0";
}
resetGame();

function whirlpool(o){
  const dx=center.x-o.x,dy=center.y-o.y;
  const a=Math.atan2(dy,dx);
  const d=Math.hypot(dx,dy);
  const pull=0.015+Math.min(0.03,(Math.max(0,350-d))/350*0.03);
  const spin=0.04+Math.min(0.08,(Math.max(0,350-d))/350*0.06);
  o.vx+=Math.cos(a)*pull - Math.sin(a)*spin;
  o.vy+=Math.sin(a)*pull + Math.cos(a)*spin;
  o.vx*=0.986;o.vy*=0.986;
}

function controlPlayer(){
  const s=0.36;
  if(keys["ArrowUp"]||keys["w"])player.vy-=s;
  if(keys["ArrowDown"]||keys["s"])player.vy+=s;
  if(keys["ArrowLeft"]||keys["a"])player.vx-=s;
  if(keys["ArrowRight"]||keys["d"])player.vx+=s;
}

function enemyAI(){
  enemy.aiT--;
  if(enemy.aiT<=0){enemy.aiT=Math.floor(randRange(30,120));enemy.mode=Math.random()<0.78?"flag":"ram";}
  let target=flag;
  if(enemy.mode==="ram" && Math.random()<0.9) target=player;
  const dx=target.x-enemy.x,dy=target.y-enemy.y,a=Math.atan2(dy,dx);
  enemy.vx+=Math.cos(a)*0.12;enemy.vy+=Math.sin(a)*0.12;
}

function move(o){o.x+=o.vx;o.y+=o.vy; if(o.inv){o.invT--; if(o.invT<=0)o.inv=false;}}

function checkFlag(o){
  if(dist(o,flag)<o.r+12){
    o.score++;
    flag=spawnFlag();
    scoreText.textContent=`プレイヤー:${player.score}　敵:${enemy.score}`;
    if(o.score>=MAX_SCORE){
      running=false;
      resultText.textContent=(o===player?"プレイヤー":"敵")+"の勝ち！";
      overlay.classList.add("visible");
    }
  }
}

function checkItem(o){
  if(!item||!item.active) return;
  if(dist(o,item)<o.r+item.radius){
    item.active=false;o.inv=true;o.invT=180;
  }
}

function handleWalls(o){
  for(const w of walls){
    if(!w.active) continue;
    const dx=o.x-w.x,dy=o.y-w.y,d=Math.hypot(dx,dy),minD=o.r+w.radius;
    if(d<minD){
      if(o.inv) continue;
      const nx=dx/d||0,ny=dy/d||0,overlap=minD-d;
      o.x+=nx*overlap;o.y+=ny*overlap;
      const dot=o.vx*nx+o.vy*ny;o.vx-=nx*dot*1.2;o.vy-=ny*dot*1.2;
    }
  }
}

function handlePlayerEnemyCollision(){
  if(player.inv||enemy.inv) return;
  const dx=enemy.x-player.x,dy=enemy.y-player.y,d=Math.hypot(dx,dy),minD=player.r+enemy.r;
  if(d<minD){
    const overlap=(minD-d)/2,nx=dx/d,ny=dy/d;
    player.x-=nx*overlap;player.y-=ny*overlap;
    enemy.x+=nx*overlap;enemy.y+=ny*overlap;
    player.vx-=nx*0.5;player.vy-=ny*0.5;
    enemy.vx+=nx*0.5;enemy.vy+=ny*0.5;
  }
}

function updateWalls(){
  wallTimer--;
  if(wallTimer<=0){walls.push(spawnWall());wallTimer=Math.floor(randRange(240,480));}
  for(const w of walls){if(w.active){w.ttl--; if(w.ttl<=0)w.active=false;}}
  walls=walls.filter(w=>w.active);
}

function updateItem(){itemTimer--; if(itemTimer<=0){item=spawnItem();itemTimer=Math.floor(randRange(600,900));}}

function drawCircle(o){ctx.beginPath();ctx.arc(o.x,o.y,o.r,0,Math.PI*2);ctx.fillStyle=o.inv?"cyan":o.color;ctx.fill();}

function drawFlag(){
  ctx.beginPath();ctx.moveTo(flag.x,flag.y-18);ctx.lineTo(flag.x,flag.y+18);ctx.strokeStyle="#ff0";ctx.lineWidth=3;ctx.stroke();
  ctx.beginPath();ctx.moveTo(flag.x,flag.y-18);ctx.lineTo(flag.x+20,flag.y-12);ctx.lineTo(flag.x,flag.y-6);ctx.closePath();ctx.fillStyle="#ff0";ctx.fill();
}

function drawItem(){if(!item||!item.active) return;ctx.beginPath();ctx.arc(item.x,item.y,item.radius,0,Math.PI*2);ctx.fillStyle="aqua";ctx.shadowBlur=12;ctx.shadowColor="cyan";ctx.fill();ctx.shadowBlur=0;}

function drawWalls(){for(const w of walls){ctx.beginPath();ctx.arc(w.x,w.y,w.radius,0,Math.PI*2);ctx.fillStyle="rgba(20,20,60,0.9)";ctx.fill();}}

function drawBackground(){for(let i=0;i<6;i++){ctx.beginPath();ctx.arc(center.x,center.y,60+i*40,0,Math.PI*2);ctx.strokeStyle=`rgba(255,255,255,${0.02+i*0.01})`;ctx.stroke();}}

function update(){
  if(!running) return;
  controlPlayer();enemyAI();
  whirlpool(player);whirlpool(enemy);
  move(player);move(enemy);
  handleWalls(player);handleWalls(enemy);
  handlePlayerEnemyCollision();
  checkFlag(player);checkFlag(enemy);
  checkItem(player);checkItem(enemy);
  updateWalls();updateItem();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();drawFlag();drawItem();drawWalls();drawCircle(player);drawCircle(enemy);
  rafId=requestAnimationFrame(update);
}

function start(){cancelAnimationFrame(rafId);rafId=requestAnimationFrame(update);}
start();
</script>
</body>
</html>
