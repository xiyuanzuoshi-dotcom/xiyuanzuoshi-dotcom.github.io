<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>バイクレーサー - ガンアクション版</title>
<style>
html,body {
  margin:0; padding:0;
  background:#111;
  overflow:hidden;
  font-family:sans-serif;
}
#game {
  display:block;
  margin:0 auto;
  background:linear-gradient(#222,#000);
}
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let roadY = 300;
let speed = 2;
let acceleration = 0;
let bike, frame, track, gameOver;
let isJumping = false;
let score = 0;
let airTime = 0;
let enemies = [];
let bullets = [];
let explosions = [];

function init(){
  frame = 0;
  speed = 2;
  acceleration = 0;
  gameOver = false;
  isJumping = false;
  score = 0;
  airTime = 0;
  bike = {x:150, y:roadY, vy:0, rot:0, grounded:true, spin:0, width:40, height:20};
  track = [];
  enemies = [];
  bullets = [];
  explosions = [];
  for(let i=0;i<2000;i++){
    track.push(Math.sin(i*0.05)*80);
  }
  update();
}

function getTrackY(offset){
  return roadY + track[Math.floor(offset)%track.length];
}

function drawRoad(offset){
  ctx.strokeStyle = "#0f0";
  ctx.lineWidth = 6;
  ctx.beginPath();
  for(let i=0;i<canvas.width;i++){
    const t = i/20 + offset;
    const y = getTrackY(t);
    if(i===0) ctx.moveTo(i,y);
    else ctx.lineTo(i,y);
  }
  ctx.stroke();
}

function drawBike(obj,color="#ff4444"){
  ctx.save();
  ctx.translate(obj.x,obj.y);
  ctx.rotate(obj.rot);
  ctx.fillStyle = color;
  ctx.fillRect(-obj.width/2,-obj.height/2,obj.width,obj.height);
  ctx.fillStyle = "#888";
  ctx.beginPath();
  ctx.arc(-15,10,8,0,Math.PI*2);
  ctx.arc(15,10,8,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawLandingIndicator(predY, isSafe){
  ctx.beginPath();
  ctx.arc(bike.x, predY, 10, 0, Math.PI*2);
  ctx.strokeStyle = isSafe ? "#0f0" : "#f00";
  ctx.lineWidth = 3;
  ctx.stroke();
}

function spawnEnemy(){
  if(Math.random()<0.02){
    const offsetX = 800 + Math.random()*400;
    const y = roadY + Math.sin(frame*0.05 + Math.random())*60;
    enemies.push({
      x:offsetX,
      y:y,
      speed:2+Math.random()*2,
      width:40,
      height:20,
      rot:0
    });
  }
}

function updateEnemies(){
  for(const e of enemies){
    e.x -= e.speed + speed*0.5;
    e.y = roadY + Math.sin((e.x+frame)*0.05)*60;
  }
  enemies = enemies.filter(e=>e.x>-100);
}

function shoot(){
  bullets.push({x:bike.x+20,y:bike.y-5,speed:10});
}

function updateBullets(){
  for(const b of bullets){
    b.x += b.speed;
  }
  bullets = bullets.filter(b=>b.x < canvas.width);
}

function drawBullets(){
  ctx.fillStyle="#ff0";
  for(const b of bullets){
    ctx.fillRect(b.x,b.y,6,2);
  }
}

function checkCollision(){
  for(const e of enemies){
    // プレイヤー衝突
    const dx = e.x - bike.x;
    const dy = e.y - bike.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < 30){
      gameOver = true;
    }
    // 飛び越えスコア
    if(e.x < bike.x && !e.scored && isJumping){
      e.scored = true;
      score += 10;
    }
  }

  // 弾と敵
  for(const b of bullets){
    for(const e of enemies){
      if(Math.abs(b.x - e.x) < 20 && Math.abs(b.y - e.y) < 15){
        explosions.push({x:e.x,y:e.y,life:20});
        e.dead = true;
        b.dead = true;
        score += 20;
      }
    }
  }
  enemies = enemies.filter(e=>!e.dead);
  bullets = bullets.filter(b=>!b.dead);
}

function drawExplosions(){
  for(const ex of explosions){
    const p = ex.life/20;
    ctx.beginPath();
    ctx.arc(ex.x,ex.y,20*(1-p),0,Math.PI*2);
    ctx.fillStyle = `rgba(255,${150+Math.random()*100},0,${p})`;
    ctx.fill();
  }
  explosions = explosions.filter(ex=>--ex.life>0);
}

function update(){
  if(gameOver) return;

  frame += speed + acceleration;
  const roadOffset = frame/20;
  const t = bike.x/20 + roadOffset;
  const groundY = getTrackY(t);
  const nextY = getTrackY(t+1);
  const slope = nextY - groundY;

  // 空中挙動
  if(isJumping){
    bike.vy += 0.5; // 重力
    bike.y += bike.vy;
    bike.rot += bike.spin * 0.05; // 回転トリック
    airTime++;
  }else{
    const diff = groundY - bike.y;
    if(Math.abs(diff) < 2){
      bike.grounded = true;
      bike.y = groundY;
      bike.vy = 0;
      bike.rot = slope * 0.02;
    }else{
      bike.y += diff * 0.3;
    }
  }

  // 着地予測と判定
  const predictedY = groundY;
  const landingAngle = Math.abs(bike.rot % (Math.PI * 2));
  const safeLanding = landingAngle < 0.5 || landingAngle > Math.PI*1.5;

  if(isJumping && bike.y >= predictedY){
    if(!safeLanding){
      gameOver = true;
    } else {
      isJumping = false;
      bike.grounded = true;
      score += Math.floor(airTime/5);
      airTime = 0;
      bike.rot = slope * 0.02;
    }
  }

  // スピード制御
  speed += acceleration * 0.1;
  if(speed<1) speed=1;
  if(speed>8) speed=8;

  // 敵・弾・衝突処理
  spawnEnemy();
  updateEnemies();
  updateBullets();
  checkCollision();

  // 描画
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRoad(roadOffset);
  enemies.forEach(e=>drawBike(e,"#44f"));
  drawBike(bike);
  drawBullets();
  drawExplosions();
  if(isJumping) drawLandingIndicator(predictedY, safeLanding);

  ctx.fillStyle="#fff";
  ctx.fillText("Speed: "+speed.toFixed(1),10,20);
  ctx.fillText("Score: "+score,canvas.width-100,20);
  if(gameOver){
    ctx.fillStyle="#f66";
    ctx.fillText("クラッシュ！SPACEでリトライ",canvas.width/2-100,canvas.height/2);
  }

  if(!gameOver) requestAnimationFrame(update);
}

// 操作
window.addEventListener("keydown", e=>{
  if(e.code==="ArrowUp") acceleration = 1;
  if(e.code==="ArrowDown") acceleration = -1;
  if(e.code==="ArrowLeft") bike.spin = -1;
  if(e.code==="ArrowRight") bike.spin = 1;
  if(e.code==="Space"){
    if(gameOver){ init(); }
    else{
      if(bike.grounded){
        // 地上でスペース → ジャンプ
        isJumping = true;
        bike.grounded = false;
        bike.vy = -10;
        airTime = 0;
      }else{
        // 空中でスペース → シュート
        shoot();
      }
    }
  }
});
window.addEventListener("keyup", e=>{
  if(e.code==="ArrowUp"||e.code==="ArrowDown") acceleration = 0;
  if(e.code==="ArrowLeft"||e.code==="ArrowRight") bike.spin = 0;
});

init();
</script>
</body>
</html>
