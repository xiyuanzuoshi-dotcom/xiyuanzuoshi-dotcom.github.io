<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mobile 3D Icons — Flick & Sensor & Effects</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0b0f;color:#fff;font-family:system-ui,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo;}
    #app{height:100%;display:flex;flex-direction:column}
    header{padding:12px 16px;font-size:16px;background:linear-gradient(0deg,rgba(255,255,255,0.02),transparent);backdrop-filter:blur(6px);display:flex;justify-content:space-between;align-items:center;}
    #canvas-wrap{flex:1;position:relative}
    canvas{display:block;width:100%;height:100%;touch-action:none}
    .hint{position:absolute;left:12px;bottom:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.4);font-size:13px}
    #sensor-toggle{background:#222;color:#fff;border:1px solid #555;border-radius:8px;padding:4px 10px;font-size:13px;}
  </style>
</head>
<body>
<div id="app">
  <header>
    3D Icons — フリックで回転
    <button id="sensor-toggle">センサーOFF</button>
  </header>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div class="hint">フリック or センサーで回してみてください</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
(() => {
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight - document.querySelector('header').offsetHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0f);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight - document.querySelector('header').offsetHeight), 0.1, 2000);
  camera.position.set(0, 0, 8);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5, 10, 7);
  scene.add(dir);

  const group = new THREE.Group();
  scene.add(group);

  function makeIcon(svgText, color=0xffffff){
    const svg = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;
    const tex = new THREE.TextureLoader().load(svg);
    tex.encoding = THREE.sRGBEncoding;

    const geometry = new THREE.BoxGeometry(1.6, 1.6, 0.28);
    const material = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.05,
      roughness: 0.4,
      map: tex
    });
    return new THREE.Mesh(geometry, material);
  }

  const svgHeart = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M12 21s-7-4.93-9.33-8.02C-0.02 8.99 3.6 4 8.5 4c2.04 0 3.6 1.02 3.5 2.5C12.6 5.02 14.16 4 16.2 4 21.1 4 24.62 8.99 21.33 12.98 19 16.07 12 21 12 21z'/></svg>`;
  const svgStar = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M12 .587l3.668 7.431L23 9.587l-5.5 5.362L19.335 24 12 20.01 4.665 24 6.5 14.949 1 9.587l7.332-1.569z'/></svg>`;
  const svgChat = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M20 2H4c-1.1 0-2 .9-2 2v14l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z'/></svg>`;

  const icons = [
    {svg: svgHeart, color: 0xff5c8a},
    {svg: svgStar, color: 0xffd166},
    {svg: svgChat, color: 0x7bd389},
    {svg: svgHeart, color: 0x82aaff},
    {svg: svgStar, color: 0xd6b3ff}
  ];

  icons.forEach((it, i) => {
    const m = makeIcon(it.svg, it.color);
    const radius = 3.0;
    const theta = (i / icons.length) * Math.PI * 2;
    m.position.set(Math.sin(theta) * radius, Math.cos(theta) * 0.6, Math.cos(theta) * radius * 0.5);
    m.rotation.x = (Math.random() - 0.5) * 0.15;
    m.rotation.y = (Math.random() - 0.5) * 0.3;
    group.add(m);
  });

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 40),
    new THREE.MeshStandardMaterial({color:0x07070a, metalness:0, roughness:1})
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -3.2;
  scene.add(ground);

  // --- interaction variables ---
  let isDown = false, lastX = 0, lastY = 0, vx = 0, vy = 0;
  const DRAG = 0.95, SPEED = 0.008, maxVel = 0.12;

  function getEventPoint(e){
    if(e.touches && e.touches.length) return {x: e.touches[0].clientX, y: e.touches[0].clientY};
    return {x: e.clientX, y: e.clientY};
  }

  function onDown(e){isDown=true;const p=getEventPoint(e);lastX=p.x;lastY=p.y;vx=vy=0;}
  function onMove(e){if(!isDown)return;e.preventDefault();const p=getEventPoint(e);const dx=p.x-lastX;const dy=p.y-lastY;lastX=p.x;lastY=p.y;group.rotation.y+=dx*SPEED;group.rotation.x+=dy*SPEED;vx=THREE.MathUtils.clamp(dx*SPEED*0.5+vx*0.5,-maxVel,maxVel);vy=THREE.MathUtils.clamp(dy*SPEED*0.5+vy*0.5,-maxVel,maxVel);}  
  function onUp(){isDown=false;}

  canvas.addEventListener('touchstart',onDown,{passive:false});
  canvas.addEventListener('touchmove',onMove,{passive:false});
  canvas.addEventListener('touchend',onUp);
  canvas.addEventListener('pointerdown',onDown);
  window.addEventListener('pointermove',onMove);
  window.addEventListener('pointerup',onUp);

  function resize(){
    const h = window.innerHeight - document.querySelector('header').offsetHeight;
    renderer.setSize(window.innerWidth, h);
    camera.aspect = window.innerWidth / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // --- sensor control ---
  let useSensor = false;
  let sensorBeta = 0, sensorGamma = 0;
  let sensorSmooth = {x:0, y:0};
  const sensorBtn = document.getElementById('sensor-toggle');

  sensorBtn.addEventListener('click', async () => {
    if (!useSensor) {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') return alert('センサーアクセスが許可されませんでした');
        } catch (e) {return alert('センサーアクセスに失敗しました');}
      }
      window.addEventListener('deviceorientation', handleOrientation);
      useSensor = true;
      sensorBtn.textContent = 'センサーON';
    } else {
      window.removeEventListener('deviceorientation', handleOrientation);
      useSensor = false;
      sensorBtn.textContent = 'センサーOFF';
    }
  });
  function handleOrientation(e){sensorBeta=e.beta||0;sensorGamma=e.gamma||0;}

  // --- rotation tracking for effects ---
  let totalRotation = 0; // accumulated absolute rotation (radians)
  lastY = group.rotation.y;
  let spinCount = 0;

  // --- particle / effect management ---
  const activeParticleSystems = [];
  const trailPoints = [];
  const trailMax = 40; // how many trail dots to keep
  const trailThreshold = 0.02; // velocity threshold to start leaving a trail

  // helper: small circular texture for particles
  function makeCircleTexture(size=64){
    const c = document.createElement('canvas'); c.width=c.height=size;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
    g.addColorStop(0,'rgba(255,255,255,1)');
    g.addColorStop(0.5,'rgba(255,255,255,0.6)');
    g.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
    const tex = new THREE.CanvasTexture(c);
    tex.encoding = THREE.sRGBEncoding;
    return tex;
  }
  const particleTexture = makeCircleTexture(64);

  // create a short ring effect (used every rotation)
  function createRing(color=0xffffcc){
    const geometry = new THREE.RingGeometry(0.9, 1.05, 64);
    const material = new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.9, side:THREE.DoubleSide});
    const ring = new THREE.Mesh(geometry, material);
    ring.rotation.x = Math.PI/2;
    ring.position.set(0, 0, 0.2);
    group.add(ring);

    let t = 0;
    const tick = () => {
      t += 0.02;
      const s = 1 + t * 2.5;
      ring.scale.set(s, s, s);
      ring.material.opacity = Math.max(0, 0.9 - t);
      if (t < 1) requestAnimationFrame(tick);
      else group.remove(ring);
    };
    tick();
  }

  // create a burst particle system (Points) at center of group
  function createBurst(color=0xfff1a6, count=32, speed=0.06, lifetime=1.0){
    const positions = new Float32Array(count*3);
    const velocities = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      positions[i*3+0]=0; positions[i*3+1]=0; positions[i*3+2]=0;
      // random spherical velocity
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      const r = 1 + Math.random()*0.5;
      velocities[i*3+0] = Math.cos(theta)*Math.sin(phi)*speed*r;
      velocities[i*3+1] = Math.sin(theta)*Math.sin(phi)*speed*r;
      velocities[i*3+2] = Math.cos(phi)*speed*r;
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const mat = new THREE.PointsMaterial({size:0.12, map:particleTexture, transparent:true, opacity:1.0, depthWrite:false});
    mat.color = new THREE.Color(color);
    const points = new THREE.Points(geom, mat);
    points.position.copy(group.position);
    points.rotation.copy(group.rotation);
    scene.add(points);

    activeParticleSystems.push({points, velocities, age:0, lifetime, geom, mat});
  }

  // big explosion for every 10 spins
  function createExplosion(){
    createBurst(0xffe27a, 120, 0.12, 1.6);
    // also a flash ring
    createRing(0xfff4d6);
  }

  // trail: leave small fading points along the rotation when spinning fast
  function leaveTrail(){
    const max = trailMax;
    // create a single point at group's current orientation
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array([0,0,0]);
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const mat = new THREE.PointsMaterial({size:0.18, map:particleTexture, transparent:true, opacity:0.9, depthWrite:false});
    const p = new THREE.Points(geom, mat);
    // position a bit forward so it's visible
    p.position.set(0,0,0.4);
    // attach to group so it rotates visually consistent
    group.add(p);
    trailPoints.push({mesh:p, age:0});
    if(trailPoints.length>max){
      const old = trailPoints.shift(); if(old){ group.remove(old.mesh); }
    }
  }

  // main trigger called on each full rotation
  function triggerRotationEffects(){
    // 1 & 2: ring + small burst
    createRing(0xffffcc);
    createBurst(0xfff1a6, 36, 0.07, 1.0);
    // if spinCount is multiple of 10 -> big explosion
    if (spinCount > 0 && spinCount % 10 === 0) {
      createExplosion();
    }
  }

  // --- animation loop ---
  function animate(){
    requestAnimationFrame(animate);

    // sensor control
    if(useSensor){
      sensorSmooth.x += ((sensorBeta/180*Math.PI) - sensorSmooth.x) * 0.05;
      sensorSmooth.y += ((sensorGamma/90*Math.PI) - sensorSmooth.y) * 0.05;
      group.rotation.x = sensorSmooth.x;
      group.rotation.y = sensorSmooth.y;
      vx = 0; vy = 0; // stop inertia while sensor active
    } else if(!isDown){
      group.rotation.y += vx;
      group.rotation.x += vy;
      vx *= DRAG; vy *= DRAG;
      if(Math.abs(vx)<0.00001)vx=0;
      if(Math.abs(vy)<0.00001)vy=0;
    }

    // --- rotation accumulation for full-rotation detection ---
    const dy = group.rotation.y - lastY;
    totalRotation += Math.abs(dy);
    lastY = group.rotation.y;
    // when totalRotation exceeds one full rotation
    const full = Math.PI*2;
    while(totalRotation >= full){
      totalRotation -= full;
      spinCount++;
      triggerRotationEffects();
    }

    // --- create trail when spinning quickly ---
    const spinSpeed = Math.abs(vx) + Math.abs(vy);
    if(spinSpeed > trailThreshold){
      // leave a trail point occasionally depending on speed
      if(Math.random() < Math.min(0.6, spinSpeed*40)) leaveTrail();
    }

    // update active particle systems
    for(let i=activeParticleSystems.length-1;i>=0;i--){
      const sys = activeParticleSystems[i];
      sys.age += 0.016;
      const positions = sys.geom.attributes.position.array;
      for(let j=0;j<positions.length/3;j++){
        positions[j*3+0] += sys.velocities[j*3+0];
        positions[j*3+1] += sys.velocities[j*3+1];
        positions[j*3+2] += sys.velocities[j*3+2];
        // apply slight gravity
        sys.velocities[j*3+1] -= 0.0015;
        // damping
        sys.velocities[j*3+0] *= 0.995; sys.velocities[j*3+1] *= 0.995; sys.velocities[j*3+2] *= 0.995;
      }
      sys.geom.attributes.position.needsUpdate = true;
      // fade opacity
      const t = sys.age / sys.lifetime;
      sys.mat.opacity = Math.max(0, 1 - t);
      if(sys.age > sys.lifetime){
        scene.remove(sys.points);
        sys.geom.dispose(); sys.mat.dispose();
        activeParticleSystems.splice(i,1);
      }
    }

    // update trail points (fade and remove)
    for(let i=trailPoints.length-1;i>=0;i--){
      const tp = trailPoints[i];
      tp.age += 0.02;
      tp.mesh.material.opacity = Math.max(0, 0.9 - tp.age);
      tp.mesh.scale.setScalar(1 + tp.age*2);
      if(tp.age > 1){ group.remove(tp.mesh); trailPoints.splice(i,1); }
    }

    renderer.render(scene, camera);
  }

  resize();
  animate();

})();
</script>
</body>
</html>
