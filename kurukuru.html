<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mobile 3D Icons — Flick & Sensor</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0b0f;color:#fff;font-family:system-ui,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo;}
    #app{height:100%;display:flex;flex-direction:column}
    header{padding:12px 16px;font-size:16px;background:linear-gradient(0deg,rgba(255,255,255,0.02),transparent);backdrop-filter:blur(6px);display:flex;justify-content:space-between;align-items:center;}
    #canvas-wrap{flex:1;position:relative}
    canvas{display:block;width:100%;height:100%;touch-action:none}
    .hint{position:absolute;left:12px;bottom:12px;padding:8px 10px;border-radius:10px;background:rgba(0,0,0,0.4);font-size:13px}
    #sensor-toggle{background:#222;color:#fff;border:1px solid #555;border-radius:8px;padding:4px 10px;font-size:13px;}
  </style>
</head>
<body>
<div id="app">
  <header>
    3D Icons — フリックで回転
    <button id="sensor-toggle">センサーOFF</button>
  </header>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div class="hint">フリック or センサーで回してみてください</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
(() => {
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight - document.querySelector('header').offsetHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0f);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight - document.querySelector('header').offsetHeight), 0.1, 2000);
  camera.position.set(0, 0, 8);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5, 10, 7);
  scene.add(dir);

  const group = new THREE.Group();
  scene.add(group);

  function makeIcon(svgText, color=0xffffff){
    const svg = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;
    const tex = new THREE.TextureLoader().load(svg);
    tex.encoding = THREE.sRGBEncoding;

    const geometry = new THREE.BoxGeometry(1.6, 1.6, 0.28);
    const material = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.05,
      roughness: 0.4,
      map: tex
    });
    return new THREE.Mesh(geometry, material);
  }

  const svgHeart = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M12 21s-7-4.93-9.33-8.02C-0.02 8.99 3.6 4 8.5 4c2.04 0 3.6 1.02 3.5 2.5C12.6 5.02 14.16 4 16.2 4 21.1 4 24.62 8.99 21.33 12.98 19 16.07 12 21 12 21z'/></svg>`;
  const svgStar = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M12 .587l3.668 7.431L23 9.587l-5.5 5.362L19.335 24 12 20.01 4.665 24 6.5 14.949 1 9.587l7.332-1.569z'/></svg>`;
  const svgChat = `<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 24 24'><path fill='#ffffff' d='M20 2H4c-1.1 0-2 .9-2 2v14l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z'/></svg>`;

  const icons = [
    {svg: svgHeart, color: 0xff5c8a},
    {svg: svgStar, color: 0xffd166},
    {svg: svgChat, color: 0x7bd389},
    {svg: svgHeart, color: 0x82aaff},
    {svg: svgStar, color: 0xd6b3ff}
  ];

  icons.forEach((it, i) => {
    const m = makeIcon(it.svg, it.color);
    const radius = 3.0;
    const theta = (i / icons.length) * Math.PI * 2;
    m.position.set(Math.sin(theta) * radius, Math.cos(theta) * 0.6, Math.cos(theta) * radius * 0.5);
    m.rotation.x = (Math.random() - 0.5) * 0.15;
    m.rotation.y = (Math.random() - 0.5) * 0.3;
    group.add(m);
  });

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(40, 40),
    new THREE.MeshStandardMaterial({color:0x07070a, metalness:0, roughness:1})
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -3.2;
  scene.add(ground);

  let isDown = false, lastX = 0, lastY = 0, vx = 0, vy = 0;
  const DRAG = 0.95, SPEED = 0.008, maxVel = 0.12;

  function getEventPoint(e){
    if(e.touches && e.touches.length) return {x: e.touches[0].clientX, y: e.touches[0].clientY};
    return {x: e.clientX, y: e.clientY};
  }

  function onDown(e){isDown=true;const p=getEventPoint(e);lastX=p.x;lastY=p.y;vx=vy=0;}
  function onMove(e){if(!isDown)return;e.preventDefault();const p=getEventPoint(e);const dx=p.x-lastX;const dy=p.y-lastY;lastX=p.x;lastY=p.y;group.rotation.y+=dx*SPEED;group.rotation.x+=dy*SPEED;vx=THREE.MathUtils.clamp(dx*SPEED*0.5+vx*0.5,-maxVel,maxVel);vy=THREE.MathUtils.clamp(dy*SPEED*0.5+vy*0.5,-maxVel,maxVel);}
  function onUp(){isDown=false;}

  canvas.addEventListener('touchstart',onDown,{passive:false});
  canvas.addEventListener('touchmove',onMove,{passive:false});
  canvas.addEventListener('touchend',onUp);
  canvas.addEventListener('pointerdown',onDown);
  window.addEventListener('pointermove',onMove);
  window.addEventListener('pointerup',onUp);

  function resize(){
    const h = window.innerHeight - document.querySelector('header').offsetHeight;
    renderer.setSize(window.innerWidth, h);
    camera.aspect = window.innerWidth / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);

  // === センサー連動 ===
  let useSensor = false;
  let sensorBeta = 0, sensorGamma = 0;
  let sensorSmooth = {x:0, y:0};
  const sensorBtn = document.getElementById('sensor-toggle');

  sensorBtn.addEventListener('click', async () => {
    if (!useSensor) {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') return alert('センサーアクセスが許可されませんでした');
        } catch (e) {return alert('センサーアクセスに失敗しました');}
      }
      window.addEventListener('deviceorientation', handleOrientation);
      useSensor = true;
      sensorBtn.textContent = 'センサーON';
    } else {
      window.removeEventListener('deviceorientation', handleOrientation);
      useSensor = false;
      sensorBtn.textContent = 'センサーOFF';
    }
  });

  function handleOrientation(e){sensorBeta=e.beta||0;sensorGamma=e.gamma||0;}

  function animate(){
    requestAnimationFrame(animate);
    if(useSensor){
      sensorSmooth.x += ((sensorBeta/180*Math.PI) - sensorSmooth.x) * 0.05;
      sensorSmooth.y += ((sensorGamma/90*Math.PI) - sensorSmooth.y) * 0.05;
      group.rotation.x = sensorSmooth.x;
      group.rotation.y = sensorSmooth.y;
    } else if(!isDown){
      group.rotation.y += vx;
      group.rotation.x += vy;
      vx *= DRAG; vy *= DRAG;
      if(Math.abs(vx)<0.00001)vx=0;
      if(Math.abs(vy)<0.00001)vy=0;
    }
    renderer.render(scene, camera);
  }

  resize();
  animate();
})();
</script>
</body>
</html>
