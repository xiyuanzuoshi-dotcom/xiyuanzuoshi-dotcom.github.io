<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>目指せ竜！鯉の滝登り - クリア演出</title>
<style>
  body { margin:0; overflow:hidden; background: linear-gradient(to top, #4da6ff, #99ccff);}
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let koi = {x:canvas.width/2-100, y:canvas.height-100, width:50, height:30, dy:0, speed:7, frame:0};
let gravity = 0.5, jumpPower=-10;
let obstacles = [], items = [], particles = [];
let gameOver=false, gameClear=false, score=0, started=false, frameCount=0;
let stage=0, prevStage=-1, transformTimer=0;

// 障害物生成
function spawnObstacle(){
  let type=Math.random()<0.7?"rock":"log";
  let width = type==="rock"?50:80;
  let x = Math.random()*(canvas.width-width-canvas.width/4);
  obstacles.push({x,y:canvas.height,width,height:20,type});
}

// アイテム生成
function spawnItem(){
  let x=Math.random()*(canvas.width-40-canvas.width/4);
  items.push({x,y:canvas.height,width:40,height:20});
}

// パーティクル生成
function spawnParticles(x, y, count=50){
  for(let i=0;i<count;i++){
    particles.push({
      x, y,
      dx:(Math.random()-0.5)*10,
      dy:(Math.random()-0.5)*10,
      life: Math.random()*40+40,
      size: Math.random()*6+3,
      color: ["yellow","white","orange"][Math.floor(Math.random()*3)]
    });
  }
}

// ステージ判定
function updateStage(){
  if(score<10) stage=0;
  else if(score<25) stage=1;
  else if(score<50) stage=2;
  else stage=3;

  if(stage!==prevStage){
    transformTimer=30;
    spawnParticles(canvas.width-canvas.width/8, canvas.height/2, 30);
    prevStage=stage;
  }

  // クリア判定
  if(stage===3 && !gameClear){
    gameClear=true;
    spawnParticles(canvas.width/2, canvas.height/2, 200); // ド派手パーティクル
  }
}

// 更新
function update(){
  if(gameOver) return;
  if(!started) return;

  frameCount++;
  updateStage();

  koi.frame +=0.2; if(koi.frame>3) koi.frame=0;

  if(!gameClear){
    koi.dy+=gravity; koi.y+=koi.dy;
    if(keys["ArrowUp"]||keys[" "]) koi.dy=jumpPower;
    if(keys["ArrowLeft"]) koi.x-=koi.speed;
    if(keys["ArrowRight"]) koi.x+=koi.speed;
    if(koi.x<0) koi.x=0;
    if(koi.x+koi.width>canvas.width-canvas.width/4) koi.x=canvas.width-canvas.width/4-koi.width;

    obstacles.forEach(ob=>{
      ob.y-=3;
      if(koi.x<ob.x+ob.width && koi.x+koi.width>ob.x &&
         koi.y<ob.y+ob.height && koi.y+koi.height>ob.y){
        if(ob.type==="rock") gameOver=true;
        if(ob.type==="log") koi.dy*=0.5;
      }
      if(ob.y+ob.height<0) score++;
    });
    obstacles=obstacles.filter(ob=>ob.y+ob.height>0);

    items.forEach(it=>{
      it.y-=3;
      if(koi.x<it.x+it.width && koi.x+koi.width>it.x &&
         koi.y<it.y+it.height && koi.y+koi.height>it.y){
        score+=5; it.collected=true;
      }
    });
    items=items.filter(it=>!it.collected && it.y+it.height>0);
    koi.x+=Math.sin(frameCount/30)*1.5;
  }

  // パーティクル更新
  particles.forEach(p=>{p.x+=p.dx;p.y+=p.dy;p.life--;});
  particles=particles.filter(p=>p.life>0);
}

// 右側イラスト描画
function drawStageIllustration(){
  const areaX=canvas.width-canvas.width/4, areaW=canvas.width/4, areaH=canvas.height;
  ctx.fillStyle="rgba(255,255,255,0.05)";
  ctx.fillRect(areaX,0,areaW,areaH);

  ctx.save(); ctx.translate(areaX+areaW/2,areaH/2);
  let wiggle=Math.sin(frameCount/20)*10;
  switch(stage){
    case 0: ctx.fillStyle="red"; ctx.fillRect(-25,-15,50,30+wiggle); break;
    case 1: ctx.fillStyle="red"; ctx.fillRect(-30,-18,60,36+wiggle); break;
    case 2: ctx.fillStyle="orange"; ctx.fillRect(-35,-20,70,40+wiggle); ctx.fillStyle="yellow"; ctx.fillRect(20,-5,10,10); break;
    case 3: ctx.fillStyle="purple"; ctx.fillRect(-40,-25,80,50+wiggle); ctx.fillStyle="yellow"; ctx.fillRect(30,-10,15,15); break;
  }
  ctx.restore();

  // 変身パーティクル
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
    ctx.fill();
  });
}

// 背景滝描画
function drawBackground(){
  ctx.fillStyle="rgba(255,255,255,0.05)";
  ctx.fillRect(0,frameCount%20,canvas.width-canvas.width/4,canvas.height);
  // 流れる泡
  for(let i=0;i<20;i++){
    ctx.fillStyle="rgba(255,255,255,0.3)";
    ctx.beginPath();
    ctx.arc(Math.random()*(canvas.width-canvas.width/4), (frameCount*2+i*50)%canvas.height,5,0,Math.PI*2);
    ctx.fill();
  }

  // 雷雲演出（ゲームクリア時）
  if(gameClear){
    ctx.fillStyle="rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,canvas.width-canvas.width/4,canvas.height);
    if(Math.random()<0.05){
      ctx.strokeStyle="yellow";
      ctx.lineWidth=4;
      ctx.beginPath();
      let startX=Math.random()*(canvas.width-canvas.width/4);
      ctx.moveTo(startX,0);
      ctx.lineTo(startX+Math.random()*50-25,canvas.height);
      ctx.stroke();
    }
  }
}

// 描画
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();

  // 鯉
  if(!gameClear){
    ctx.fillStyle="red";
    let wiggle=Math.sin(koi.frame*Math.PI*2/3)*10;
    ctx.fillRect(koi.x,koi.y,koi.width,koi.height+wiggle);
  }

  // 障害物
  obstacles.forEach(ob=>{
    ctx.fillStyle=ob.type==="rock"?"gray":"brown";
    ctx.fillRect(ob.x,ob.y,ob.width,ob.height);
  });
  // アイテム
  items.forEach(it=>{ctx.fillStyle="green"; ctx.fillRect(it.x,it.y,it.width,it.height);});

  drawStageIllustration();

  ctx.fillStyle="white"; ctx.font="30px Arial";
  ctx.fillText("Score: "+score,20,50);

  if(!started){
    ctx.fillStyle="black"; ctx.font="40px Arial";
    ctx.fillText("Press any key to start",canvas.width/2-200,canvas.height/2);
  }

  if(gameOver){
    ctx.fillStyle="black"; ctx.font="60px Arial";
    ctx.fillText("GAME OVER",canvas.width/2-180,canvas.height/2);
  }

  if(gameClear){
    ctx.fillStyle="gold"; ctx.font="60px Arial";
    ctx.fillText("GAME CLEAR!",canvas.width/2-200,canvas.height/2);
  }
}

// キー操作
let keys={};
window.addEventListener("keydown",e=>{keys[e.key]=true;if(!started) started=true;});
window.addEventListener("keyup",e=>keys[e.key]=false);

// 周期
setInterval(()=>{if(started&&!gameOver&&!gameClear) spawnObstacle();},1500);
setInterval(()=>{if(started&&!gameOver&&!gameClear) spawnItem();},3000);

// ループ
function loop(){update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
