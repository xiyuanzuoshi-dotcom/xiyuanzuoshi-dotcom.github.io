<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Bike Run 2D - Burning Curve Edition</title>
<style>
  html,body {margin:0;padding:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:sans-serif;}
  #hud {position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;}
  #hud div {margin:4px 0;font-size:14px;}
  #controls {position:absolute;right:10px;bottom:10px;z-index:10;display:flex;gap:8px;}
  .btn {width:80px;height:48px;border-radius:8px;background:rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;color:#fff;font-size:14px;user-select:none;-webkit-user-select:none;}
  #message {position:absolute;left:50%;top:60%;transform:translateX(-50%);background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:8px;z-index:20;}
  #tiltBtn {position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#2a9d8f;color:#fff;border:none;border-radius:8px;padding:12px 20px;font-size:16px;z-index:30;}
  canvas {display:block;width:100%;height:100%;background:#000;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<!-- バーニングモードテロップ -->
<div id="burningText">🔥やけくそバーニングモード突入！🔥</div>

<style>
#burningText {
  position:absolute;
  top:40%;
  left:50%;
  transform:translate(-50%,-50%) scale(0);
  font-size:48px;
  font-weight:900;
  color:#ff3300;
  text-shadow:0 0 10px #ff9900,0 0 20px #ffff00,0 0 30px #ff3300;
  opacity:0;
  z-index:9999;
  pointer-events:none;
}

.burning-animate {
  animation: burningIn 1.5s ease-out forwards, burningShake 0.5s ease-in-out 1.5s 2, burningFade 1.5s ease-in-out 3.5s forwards;
}

@keyframes burningIn {
  0% { transform:translate(-50%,-50%) scale(0); opacity:0; }
  50% { transform:translate(-50%,-50%) scale(1.3); opacity:1; color:#ff6600; }
  100% { transform:translate(-50%,-50%) scale(1); color:#ffcc00; }
}

@keyframes burningShake {
  0% { transform:translate(-50%,-50%) rotate(0deg); }
  25% { transform:translate(-50%,-50%) rotate(2deg); }
  50% { transform:translate(-50%,-50%) rotate(-2deg); }
  75% { transform:translate(-50%,-50%) rotate(1deg); }
  100% { transform:translate(-50%,-50%) rotate(0deg); }
}

@keyframes burningFade {
  0% { opacity:1; transform:translate(-50%,-50%) scale(1); }
  100% { opacity:0; transform:translate(-50%,-50%) scale(2); }
}
</style>

<script>
// バーニングモードテロップ演出関数
function showBurningText() {
  const text = document.getElementById("burningText");
  text.classList.remove("burning-animate"); // 再利用可能にする
  void text.offsetWidth; // 再トリガー用
  text.classList.add("burning-animate");
}

// うんち踏んだときに呼び出す
function applyPoop(){
  if(!burningMode){
    burningMode=true;
    burningTimer=6;
    baseSpeed=20;
    shakeEffect=0.6;
    flashAlpha=0.3;
    showBurningText(); // テロップ表示
  }
  addParticle(width/2+pos.x,height*0.85,"flame");
}
</script>


<div id="hud">
  <div>Time: <span id="timer">--</span></div>
  <div>Distance: <span id="distance">0</span> / <span id="goalDist">1200</span></div>
  <div>Speed: <span id="speed">0</span> m/s</div>
  <div>Damage: <span id="damage">0</span>%</div>
</div>

<div id="controls">
  <div id="brake" class="btn">BRAKE</div>
  <div id="accel" class="btn">ACCEL</div>
</div>

 

<div id="message">傾けてハンドル、タップでアクセル／ブレーキ！</div>
<button id="tiltBtn">傾き操作を有効にする</button>

<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const HUD={
  timerEl:document.getElementById('timer'),
  distanceEl:document.getElementById('distance'),
  goalDistEl:document.getElementById('goalDist'),
  speedEl:document.getElementById('speed'),
  damageEl:document.getElementById('damage'),
};
let width,height;
function resize(){width=window.innerWidth;height=window.innerHeight;canvas.width=width;canvas.height=height;}
window.addEventListener('resize',resize);resize();

// === ゲーム変数 ===
let baseSpeed=12,speed=0;
let accelPower=6,brakePower=10;
let steerSensitivity=0.05;
let pos={x:0,z:0};
let cam={x:0,y:0};
// 周回コース設定
let trackLength=1200, lapsNeeded=1, lapsCompleted=0;
let goalDistance=trackLength, timer=60, running=true, damage=0;
// HUD にトラック長を表示
HUD.goalDistEl.textContent = trackLength;
let lastCollision=-999,collisionCooldown=1;
let input={accel:false,brake:false,gamma:0};
let wheelie={active:false,timer:0,angle:0};
let particles=[],obstacles=[];
let shakeEffect=0,flashAlpha=0;
let burningMode=false,burningTimer=0;

// === コース ===
function roadCurve(z){
  return Math.sin(z/280)*140 + Math.sin(z/650)*90;
}
function roadWidthAt(z){return width*(0.3+0.15*Math.sin(z/400));}

// === 障害物生成（ランダム化） ===
const types=["cone","car","poop"];
function generateObstacles(){
  obstacles=[];
  // 周回コース用にトラック長 (trackLength) の範囲で障害物を生成
  for(let i=50;i<trackLength;i+=100+Math.random()*150){
    obstacles.push({
      z:i,
      x:(Math.random()*2-1)*(width*0.25),
      size:20+Math.random()*30,
      type: types[Math.floor(Math.random()*types.length)]
    });
  }
}
generateObstacles();

// PC用デバッグキー
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowRight') input.accel=true;
  if(e.key==='ArrowLeft') input.brake=true;
  if(e.key==='r' || e.key==='R') generateObstacles(); // 障害物リセット
  if(e.key==='p' || e.key==='P') applyPoop();        // バーニングモード強制
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowRight') input.accel=false;
  if(e.key==='ArrowLeft') input.brake=false;
});

// === 操作 ===
const accelBtn=document.getElementById('accel'),brakeBtn=document.getElementById('brake');
accelBtn.addEventListener('touchstart',e=>{e.preventDefault();input.accel=true;});
accelBtn.addEventListener('touchend',e=>{e.preventDefault();input.accel=false;});
brakeBtn.addEventListener('touchstart',e=>{e.preventDefault();input.brake=true;});
brakeBtn.addEventListener('touchend',e=>{e.preventDefault();input.brake=false;});
const tiltBtn=document.getElementById('tiltBtn');
tiltBtn.addEventListener('click',()=>{
  if(typeof DeviceOrientationEvent.requestPermission==='function'){
    DeviceOrientationEvent.requestPermission().then(state=>{
      if(state==='granted')enableTilt();
      tiltBtn.style.display='none';
    }).catch(()=>alert("傾きセンサーが許可されませんでした。"));
  }else{enableTilt();tiltBtn.style.display='none';}
});
function enableTilt(){window.addEventListener('deviceorientation',e=>{input.gamma=e.gamma||0;});}
window.addEventListener('keydown',e=>{
  if(e.key==="ArrowRight")input.accel=true;
  if(e.key==="ArrowLeft")input.brake=true;
});
window.addEventListener('keyup',e=>{
  if(e.key==="ArrowRight")input.accel=false;
  if(e.key==="ArrowLeft")input.brake=false;
});

// === パーティクル ===
function addParticle(x,y,type="flame"){
  particles.push({x,y,type,vx:(Math.random()-0.5)*2,vy:type==="spark"?-1-Math.random()*1.5:-2-Math.random()*2,life:type==="spark"?0.8:0.5,size:type==="spark"?3+Math.random()*3:4+Math.random()*4});
}
function updateParticles(dt){for(let p of particles){p.x+=p.vx;p.y+=p.vy;p.life-=dt;}particles=particles.filter(p=>p.life>0);}
function drawParticles(){
  for(let p of particles){
    const a=Math.max(0,p.life/(p.type==="spark"?0.8:0.5));
    ctx.fillStyle=p.type==="flame"?`rgba(255,${Math.floor(100+155*a)},0,${a})`:`rgba(255,255,${200+Math.random()*55},${a})`;
    ctx.beginPath();ctx.arc(p.x,p.y,p.size*a,0,Math.PI*2);ctx.fill();
  }
}

// === 描画 ===
function draw(){
  ctx.save();
  if(shakeEffect>0)ctx.translate((Math.random()-0.5)*10*shakeEffect,(Math.random()-0.5)*10*shakeEffect);
  ctx.clearRect(0,0,width,height);

  cam.x += (pos.x - cam.x)*0.05;
  const roadCenterX=width/2+roadCurve(pos.z)-cam.x;
  const roadHalfWidth=roadWidthAt(pos.z);
  const tiltAngle=(roadCurve(pos.z+50)-roadCurve(pos.z-50))/200;

  // 道路傾斜演出
  ctx.save();
  ctx.translate(width/2,height/2);
  ctx.rotate(tiltAngle*0.005);
  ctx.translate(-width/2,-height/2);

  // 背景を黒一色に変更
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.moveTo(roadCenterX-roadHalfWidth,0);
  ctx.lineTo(roadCenterX+roadHalfWidth,0);
  ctx.lineTo(roadCenterX+roadHalfWidth*0.6,height);
  ctx.lineTo(roadCenterX-roadHalfWidth*0.6,height);
  ctx.closePath();
  ctx.fill();

  // ガードレール：カーブ追従
  const step=20;
  ctx.strokeStyle="#a22";ctx.lineWidth=8;
  ctx.beginPath();
  for(let z=0;z<height;z+=step){
    const cx=roadCenterX-roadHalfWidth-10+Math.sin((pos.z+z*2)/300)*20;
    if(z===0)ctx.moveTo(cx,z);else ctx.lineTo(cx,z);
  }
  ctx.stroke();

  ctx.beginPath();
  for(let z=0;z<height;z+=step){
    const cx=roadCenterX+roadHalfWidth+10+Math.sin((pos.z+z*2)/300)*20;
    if(z===0)ctx.moveTo(cx,z);else ctx.lineTo(cx,z);
  }
  ctx.stroke();
  ctx.restore();

  // 障害物
  for(let ob of obstacles){
  // 周回コース対応: 相対Zをトラック長で補正して前方のみを描画
  let relZ = ob.z - pos.z;
  if(relZ < 0) relZ += trackLength;
  if(relZ > 120) continue; // 描画範囲外
  const y = height - relZ * 10;
    const x=roadCenterX+ob.x;
    if(ob.type==="cone"){
      ctx.fillStyle="#fa0";
      ctx.beginPath();ctx.moveTo(x,y-ob.size);ctx.lineTo(x-ob.size/2,y);ctx.lineTo(x+ob.size/2,y);ctx.closePath();ctx.fill();
    }else if(ob.type==="car"){
      ctx.fillStyle="#0af";
      ctx.fillRect(x-ob.size,y-ob.size/2,ob.size*2,ob.size);
    }else if(ob.type==="poop"){
      ctx.fillStyle="#6b3e1e";
      ctx.beginPath();
      ctx.arc(x,y-ob.size/3,ob.size/1.5,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x,y-ob.size,ob.size/2,0,Math.PI*2);
      ctx.fill();
    }
    const dx=(x-(width/2+pos.x)),dy=(y-(height*0.8));
    if(Math.abs(dx)<ob.size&&Math.abs(dy)<ob.size){
      if(ob.type==="poop"){applyPoop();}
      else applyCollision();
      // 衝突した障害物はトラック外に移動させる
      ob.z = (ob.z + trackLength) % (trackLength + 10000);
    }
  }

  // バイク
  const bikeY=height*0.8,bikeX=width/2+pos.x;
  ctx.fillStyle=burningMode?"#ff3300":(wheelie.active?"#ffd700":"#2a9d8f");
  ctx.fillRect(bikeX-15,bikeY-30,30,60);

  drawParticles();

  if(flashAlpha>0){ctx.fillStyle=`rgba(255,0,0,${flashAlpha})`;ctx.fillRect(0,0,width,height);}
  ctx.restore();

  HUD.timerEl.textContent=timer.toFixed(2);
  // 距離表示は周回内の距離を表示（pos.z がトラック内に収まるようにしたため直接表示）
  HUD.distanceEl.textContent = pos.z.toFixed(1);
  HUD.speedEl.textContent=speed.toFixed(2);
  HUD.damageEl.textContent=Math.round(damage);
}

// === 更新 ===
let lastTime=performance.now();
function update(){
  if(!running)return;
  const now=performance.now();
  const dt=Math.min((now-lastTime)/1000,0.05);
  lastTime=now;

  timer-=dt;if(timer<=0){timer=0;running=false;showResult(false);}

  // バーニングモード処理
  if(burningMode){
    burningTimer-=dt;
    addParticle(width/2+pos.x,height*0.8,"flame");
    if(burningTimer<=0){burningMode=false;baseSpeed=12;}
  }

  const dmgFactor=Math.min(damage/100,0.9);
  const maxSpeed=baseSpeed*(1-dmgFactor);
  if(input.accel){speed+=accelPower*dt;wheelie.timer+=dt;}
  else{speed-=2*dt;wheelie.timer=Math.max(0,wheelie.timer-dt*2);}
  if(input.brake)speed-=brakePower*dt;
  speed=Math.max(0,Math.min(maxSpeed,speed));

  if(wheelie.timer>2.0&&!wheelie.active)wheelie.active=true;
  if(!input.accel&&wheelie.active)wheelie.active=false;

  pos.x+=(-input.gamma*steerSensitivity)*dt*500*(wheelie.active?1.4:1);
  pos.z+=speed*dt*10;

  // 周回処理: トラック長を超えたら周回カウント
  if(pos.z >= trackLength){
    pos.z -= trackLength;
    lapsCompleted++;
    if(lapsCompleted >= lapsNeeded){
      running = false;
      showResult(true);
    }
  }

  const roadCenterX=width/2+roadCurve(pos.z);
  const roadHalfWidth=roadWidthAt(pos.z);
  if(Math.abs(pos.x)>roadHalfWidth-20){
    const nowSec=now/1000;
    if(nowSec-lastCollision>collisionCooldown){lastCollision=nowSec;applyCollision();}
    pos.x=Math.sign(pos.x)*(roadHalfWidth-20);speed*=0.6;
  }

  if(wheelie.active&&Math.random()<0.3)addParticle(width/2+pos.x,height*0.8,"spark");
  updateParticles(dt);
  // 周回化により直線ゴールの判定は不要（周回カウントでゴール判定を行う）
  if(shakeEffect>0)shakeEffect-=dt*2;
  if(flashAlpha>0)flashAlpha-=dt*3;
}

// === 効果 ===
function applyCollision(){
  if(burningMode)return;
  timer=Math.max(0,timer-3);
  damage=Math.min(100,damage+12);
  shakeEffect=1;flashAlpha=0.5;
  speed*=0.5;
}

// 💩 うんち → バーニングモード！
function applyPoop(){
  if(!burningMode){
    burningMode=true;
    burningTimer=6;
    baseSpeed=20;
    shakeEffect=0.6;
    flashAlpha=0.3;
    showBurningText();
  }
  addParticle(width/2+pos.x,height*0.85,"flame");
}

function showResult(clear){
  setTimeout(()=>{
  alert(clear?`★ GOAL!\nDamage:${Math.round(damage)}%\nDistance:${trackLength}`:`✖ TIME UP\nDamage:${Math.round(damage)}%\nDistance:${pos.z.toFixed(1)} / ${trackLength}`);
    if(confirm("Retry?"))resetGame();
  },100);
}
function resetGame(){
  pos={x:0,z:0};speed=0;timer=60;damage=0;
  wheelie={active:false,timer:0,angle:0};
  particles=[];running=true;burningMode=false;baseSpeed=12;
  lapsCompleted = 0;
  // 障害物は再生成して位置をリセット
  generateObstacles();
}

function loop(){if(running)update();draw();requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
