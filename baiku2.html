<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Bike Run 2D - Wheelie Edition</title>
<style>
  html,body {
    margin:0; padding:0; height:100%; overflow:hidden;
    background:#111; color:#fff; font-family:sans-serif;
  }
  #hud {
    position:absolute; top:10px; left:10px; z-index:10;
    background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;
  }
  #hud div { margin:4px 0; font-size:14px; }
  #controls {
    position:absolute; right:10px; bottom:10px; z-index:10; display:flex; gap:8px;
  }
  .btn {
    width:80px; height:48px; border-radius:8px;
    background:rgba(255,255,255,0.1); display:flex; align-items:center; justify-content:center;
    color:#fff; font-size:14px; user-select:none; -webkit-user-select:none;
  }
  #message {
    position:absolute; left:50%; top:60%; transform:translateX(-50%);
    background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; z-index:20;
  }
  #tiltBtn {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    background:#2a9d8f; color:#fff; border:none; border-radius:8px;
    padding:12px 20px; font-size:16px; z-index:30;
  }
  canvas { display:block; width:100%; height:100%; background:#222; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div>Time: <span id="timer">--</span></div>
  <div>Distance: <span id="distance">0</span> / <span id="goalDist">500</span></div>
  <div>Speed: <span id="speed">0</span> m/s</div>
  <div>Damage: <span id="damage">0</span>%</div>
</div>

<div id="controls">
  <div id="brake" class="btn">BRAKE</div>
  <div id="accel" class="btn">ACCEL</div>
</div>

<div id="message">傾けてハンドル、タップでアクセル／ブレーキ！</div>
<button id="tiltBtn">傾き操作を有効にする</button>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const HUD = {
  timerEl: document.getElementById('timer'),
  distanceEl: document.getElementById('distance'),
  goalDistEl: document.getElementById('goalDist'),
  speedEl: document.getElementById('speed'),
  damageEl: document.getElementById('damage'),
};
let width, height;
function resize(){
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// === ゲーム変数 ===
let baseSpeed = 12;
let speed = 0;
let accelPower = 6;
let brakePower = 10;
let steerSensitivity = 0.06;
let roadHalfWidth = width * 0.35;
let pos = { x: 0, z: 0 };
let goalDistance = 500;
let timer = 60;
let running = true;
let damage = 0;
let lastCollision = -999;
let collisionCooldown = 1;
let input = { accel:false, brake:false, gamma:0 };
let wheelie = { active:false, timer:0, angle:0 };
let particles = [];

document.getElementById('goalDist').textContent = goalDistance;

// === タッチ操作 ===
const accelBtn = document.getElementById('accel');
const brakeBtn = document.getElementById('brake');
accelBtn.addEventListener('touchstart', e=>{ e.preventDefault(); input.accel=true; });
accelBtn.addEventListener('touchend', e=>{ e.preventDefault(); input.accel=false; });
brakeBtn.addEventListener('touchstart', e=>{ e.preventDefault(); input.brake=true; });
brakeBtn.addEventListener('touchend', e=>{ e.preventDefault(); input.brake=false; });

// === デバイス傾き ===
const tiltBtn = document.getElementById('tiltBtn');
tiltBtn.addEventListener('click', ()=>{
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(state=>{
      if (state === 'granted') enableTilt();
      tiltBtn.style.display = 'none';
    }).catch(()=> alert("傾きセンサーが許可されませんでした。"));
  } else {
    enableTilt();
    tiltBtn.style.display = 'none';
  }
});
function enableTilt(){
  window.addEventListener('deviceorientation', e=>{
    input.gamma = e.gamma || 0;
  });
}

// === キーボード操作 ===
window.addEventListener('keydown', e=>{
  if (e.key === "ArrowRight") input.accel = true;
  if (e.key === "ArrowLeft") input.brake = true;
});
window.addEventListener('keyup', e=>{
  if (e.key === "ArrowRight") input.accel = false;
  if (e.key === "ArrowLeft") input.brake = false;
});

// === 粒子（炎エフェクト用） ===
function addParticle(x, y){
  particles.push({
    x, y,
    vx: (Math.random()-0.5)*2,
    vy: -2 - Math.random()*2,
    life: 0.6
  });
}
function updateParticles(dt){
  for(let p of particles){
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
  }
  particles = particles.filter(p => p.life > 0);
}
function drawParticles(){
  for(let p of particles){
    const alpha = Math.max(0, p.life/0.6);
    ctx.fillStyle = `rgba(255,${Math.floor(100+150*alpha)},0,${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 5*alpha, 0, Math.PI*2);
    ctx.fill();
  }
}

// === 描画 ===
function draw(){
  ctx.clearRect(0,0,width,height);

  // 道路
  ctx.fillStyle = "#333";
  ctx.fillRect(width/2 - roadHalfWidth, 0, roadHalfWidth*2, height);

  // 下部アニメーション
  const animHeight = 60;
  const grad = ctx.createLinearGradient(0, height-animHeight, 0, height);
  if(wheelie.active){
    grad.addColorStop(0, "rgba(255,100,0,0.5)");
    grad.addColorStop(1, "rgba(255,0,0,0.8)");
  }else{
    grad.addColorStop(0, "rgba(100,255,255,0.3)");
    grad.addColorStop(1, "rgba(0,150,255,0.6)");
  }
  ctx.fillStyle = grad;
  ctx.fillRect(0, height-animHeight, width, animHeight);

  // ガードレール
  ctx.fillStyle = "#800";
  ctx.fillRect(width/2 - roadHalfWidth - 10, 0, 10, height);
  ctx.fillRect(width/2 + roadHalfWidth, 0, 10, height);

  // バイク
  const bikeY = height * 0.8;
  const bikeX = width/2 + pos.x;
  ctx.save();
  ctx.translate(bikeX, bikeY);
  ctx.rotate((input.gamma * -0.02) + wheelie.angle);
  ctx.fillStyle = wheelie.active ? "#ff4500" : "#2a9d8f";
  ctx.fillRect(-15, -30, 30, 60);
  ctx.restore();

  drawParticles();

  // 距離マーカー
  ctx.strokeStyle = "#ff0";
  for (let i=0;i<10;i++){
    const z = (i*50 - (pos.z%50)) * 10;
    const y = height - z;
    if (y < -10 || y > height) continue;
    ctx.beginPath();
    ctx.moveTo(width/2 - roadHalfWidth + 10, y);
    ctx.lineTo(width/2 + roadHalfWidth - 10, y);
    ctx.stroke();
  }

  // HUD
  HUD.timerEl.textContent = timer.toFixed(2);
  HUD.distanceEl.textContent = Math.min(pos.z, goalDistance).toFixed(1);
  HUD.speedEl.textContent = speed.toFixed(2);
  HUD.damageEl.textContent = Math.round(damage);
}

// === ゲーム更新 ===
let lastTime = performance.now();
function update(){
  if (!running) return;
  const now = performance.now();
  const dt = Math.min((now - lastTime)/1000, 0.05);
  lastTime = now;

  timer -= dt;
  if (timer <= 0){ timer=0; running=false; showResult(false); }

  const damageFactor = Math.min(damage/100, 0.9);
  const maxSpeed = baseSpeed * (1 - damageFactor);

  if (input.accel){
    speed += accelPower * dt;
    wheelie.timer += dt;
  } else {
    speed -= 2 * dt;
    wheelie.timer = Math.max(0, wheelie.timer - dt*2);
  }
  if (input.brake) speed -= brakePower * dt;

  speed = Math.max(0, Math.min(maxSpeed, speed));

  // === ウイリー判定 ===
  if (wheelie.timer > 1.0 && !wheelie.active){
    wheelie.active = true;
  }
  if (!input.accel && wheelie.active){
    wheelie.active = false;
  }

  // ウイリー角度
  wheelie.angle += ((wheelie.active ? -0.35 : 0) - wheelie.angle) * dt * 3;

  // スマホ傾きによる横移動
  pos.x += (-input.gamma * steerSensitivity) * dt * 500 * (wheelie.active ? 1.5 : 1);
  pos.z += speed * dt * 10;

  // 壁判定
  if (Math.abs(pos.x) > roadHalfWidth - 20){
    const nowSec = now / 1000;
    if (nowSec - lastCollision > collisionCooldown){
      lastCollision = nowSec;
      applyCollision();
    }
    pos.x = Math.sign(pos.x) * (roadHalfWidth - 20);
    speed *= 0.6;
  }

  // 炎パーティクル
  if (wheelie.active){
    addParticle(width/2 + pos.x, height*0.8 + 25);
  }
  updateParticles(dt);

  // ゴール
  if (pos.z >= goalDistance){
    running=false; showResult(true);
  }
}

function applyCollision(){
  timer = Math.max(0, timer - 3);
  damage = Math.min(100, damage + 12);
}

function showResult(clear){
  setTimeout(()=>{
    alert(clear ? `★ GOAL!\nDamage:${Math.round(damage)}%\nDistance:${goalDistance}` 
                : `✖ TIME UP\nDamage:${Math.round(damage)}%\nDistance:${pos.z.toFixed(1)} / ${goalDistance}`);
    if (confirm("Retry?")) resetGame();
  },100);
}

function resetGame(){
  pos = {x:0,z:0};
  speed = 0;
  timer = 60;
  damage = 0;
  wheelie = {active:false, timer:0, angle:0};
  particles = [];
  running = true;
}

// === ループ ===
function loop(){
  if (running) update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
