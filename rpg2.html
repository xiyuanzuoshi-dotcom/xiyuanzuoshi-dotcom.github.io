<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>蒼の部屋RPG</title>
<style>
body{background:#cce0ff;margin:0;overflow:hidden;}
canvas{display:block;margin:20px auto;border:3px solid #333;touch-action:none;image-rendering:pixelated;}
</style>
</head>
<body>
<canvas id="game" width="480" height="320"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// マップ設定
const tileSize = 48;
const mapWidth = 10;
const mapHeight = 7;
const map = [
 [0,0,0,0,0,0,0,0,0,0],
 [0,1,1,1,1,1,1,1,1,0],
 [0,1,0,0,0,0,0,0,1,0],
 [0,1,0,1,1,1,1,0,1,0],
 [0,1,0,1,0,0,1,0,1,0],
 [0,1,1,1,1,1,1,1,1,0],
 [0,0,0,0,0,0,0,0,0,0]
];

// プレイヤー設定
let player = {x:2, y:2, px:2, py:2, moveX:0, moveY:0, moving:false, speed:4};

// 村人設定
let npcs = [
 {x:4, y:3, color:"orange"},
 {x:6, y:5, color:"purple"}
];

// 移動方向
let moveDir = null;
let touchActive = false;

// タイル描画
function drawTile(x, y, type){
 if(type===0){ctx.fillStyle="#2277cc";}
 else{ctx.fillStyle="#77cc55";}
 ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
}

// 描画
function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 // マップ
 for(let y=0;y<mapHeight;y++){
   for(let x=0;x<mapWidth;x++){
     drawTile(x,y,map[y][x]);
   }
 }
 // 村人
 for(let npc of npcs){
   ctx.fillStyle = npc.color;
   ctx.beginPath();
   ctx.arc(npc.x*tileSize+tileSize/2, npc.y*tileSize+tileSize/2, tileSize/2.5, 0, Math.PI*2);
   ctx.fill();
 }
 // プレイヤー
 const px = player.px*tileSize + player.moveX;
 const py = player.py*tileSize + player.moveY;
 ctx.fillStyle="red";
 ctx.beginPath();
 ctx.arc(px+tileSize/2, py+tileSize/2, tileSize/2.5, 0, Math.PI*2);
 ctx.fill();
}

// 移動開始
function startMove(dir){
 if(player.moving) return;
 let dx=0, dy=0;
 if(dir==="left") dx=-1;
 if(dir==="right") dx=1;
 if(dir==="up") dy=-1;
 if(dir==="down") dy=1;
 const nx = player.px + dx;
 const ny = player.py + dy;
 if(map[ny][nx]===1){
   player.moving=true;
   player.px=nx; player.py=ny;
   player.moveX=-dx*tileSize;
   player.moveY=-dy*tileSize;
   const step=()=>{
     player.moveX+=dx*player.speed;
     player.moveY+=dy*player.speed;
     if(Math.abs(player.moveX)===0 && Math.abs(player.moveY)===0){
       player.moving=false;
     }
     if(Math.abs(player.moveX) < tileSize && Math.abs(player.moveY) < tileSize && player.moving){
       requestAnimationFrame(step);
     }else{
       player.moveX=0;
       player.moveY=0;
       player.moving=false;
     }
   };
   requestAnimationFrame(step);
 }
}

// タッチ方向判定
function getDir(touch){
 const rect = canvas.getBoundingClientRect();
 const x = touch.clientX - rect.left;
 const y = touch.clientY - rect.top;
 const cx = canvas.width/2;
 const cy = canvas.height/2;
 const dx = x - cx;
 const dy = y - cy;
 if(Math.abs(dx)>Math.abs(dy)){
   return dx>0 ? "right" : "left";
 }else{
   return dy>0 ? "down" : "up";
 }
}

// タッチイベント
canvas.addEventListener("touchstart",e=>{
 touchActive=true;
 moveDir=getDir(e.touches[0]);
 startMove(moveDir);
});
canvas.addEventListener("touchend",()=>{
 touchActive=false;
 moveDir=null;
});
canvas.addEventListener("touchmove",e=>{
 e.preventDefault();
 const dir = getDir(e.touches[0]);
 if(dir!==moveDir){
   moveDir=dir;
 }
});

// メインループ
function loop(){
 if(touchActive && !player.moving && moveDir){
   startMove(moveDir);
 }
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
