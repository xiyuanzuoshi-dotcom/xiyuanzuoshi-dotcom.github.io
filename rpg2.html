<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>スマホドットRPG — NPC会話＋当たり判定</title>
<style>
html,body{height:100%;margin:0;background:#071018;color:#e6f7ff;font-family:sans-serif;touch-action:none;}
#wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px}
canvas{image-rendering:pixelated;border:6px solid #111;background:#073;display:block;}
.npc-dialog{
  position:absolute;
  background:rgba(0,0,0,0.85);
  color:#fff;
  border:2px solid #ccc;
  border-radius:10px;
  padding:6px 10px;
  font-size:14px;
  line-height:1.4;
  max-width:180px;
  display:none;
  transform:translate(-50%,-100%);
  user-select:none;
}
</style>
</head>
<body>
<div id="wrap">
  <h3>スマホドットRPG — NPC会話＋当たり判定</h3>
  <div style="position:relative;">
    <canvas id="game" width="480" height="384"></canvas>
    <div id="npcDialog" class="npc-dialog"></div>
  </div>
</div>

<script>
/* === 基本設定 === */
const TILE=48, WORLD_W=20, WORLD_H=15;
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const dialogEl=document.getElementById('npcDialog');

const world=[
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
 [1,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,3,3,0,1],
 [1,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,3,3,0,1],
 [1,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,1],
 [1,0,2,2,2,0,0,0,0,0,0,2,2,2,0,0,0,0,0,1],
 [1,0,2,0,2,0,0,0,0,0,0,2,0,2,0,0,0,0,0,1],
 [1,0,2,2,2,0,0,0,0,0,0,2,2,2,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const player={x:10,y:7,dir:'down',moving:false,px:10*TILE,py:7*TILE};
const camera={x:0,y:0,targetX:0,targetY:0};
const NPCS=[
  {
    x:8,y:6,color:'#ff4444',
    dialog:[
      'ようこそ、この村へ！',
      'この先にある森には古い祠があるんだ。',
      '誰も近づかないけど、夜になると灯りが見えるって噂だよ。',
      '…君、本当に行くつもりなのかい？'
    ]
  },
  {
    x:15,y:9,color:'#ffaa00',
    dialog:[
      'やあ、旅人さん！',
      'この村は昔、湖の底に沈みかけたことがあるんだ。',
      'けど、不思議な力が働いて助かったらしい。',
      '今でも湖のほとりでは、青白い光が時々見えるそうだよ。'
    ]
  },
  {
    x:5,y:11,color:'#44aaff',
    dialog:[
      '……眠い。',
      '昨日は遅くまで井戸の修理をしてたんだ。',
      'まったく、あの子猫が落ちるからって言うけど…',
      'あぁもう、寝かせてくれ…。'
    ]
  }
];

let activeNPC=null;
let messageIndex=0;
let cancelHold=false;
let holdTimer=null;

/* === 当たり判定 === */
function isWalkable(x,y){
  if(x<0||y<0||x>=WORLD_W||y>=WORLD_H)return false;
  const t=world[y][x];
  if(t===1||t===4)return false;
  for(const npc of NPCS){ if(npc.x===x && npc.y===y) return false; }
  return true;
}

/* === プレイヤー移動 === */
function attemptMove(dir){
  if(player.moving)return;
  let nx=player.x,ny=player.y;
  if(dir==='up')ny--;if(dir==='down')ny++;if(dir==='left')nx--;if(dir==='right')nx++;
  if(!isWalkable(nx,ny))return;
  player.moving=true;player.dir=dir;
  const startX=player.x*TILE,startY=player.y*TILE,targetX=nx*TILE,targetY=ny*TILE;
  const duration=120,startTime=performance.now();
  function step(){
    const t=(performance.now()-startTime)/duration;
    if(t>=1){player.px=targetX;player.py=targetY;player.x=nx;player.y=ny;player.moving=false;}
    else{player.px=startX+(targetX-startX)*t;player.py=startY+(targetY-startY)*t;requestAnimationFrame(step);}
  }requestAnimationFrame(step);
}

/* === カメラ追従 === */
function updateCameraTarget(){
  let tx=player.px+TILE/2-480/2;
  let ty=player.py+TILE/2-384/2;
  tx=Math.max(0,Math.min(tx,WORLD_W*TILE-480));
  ty=Math.max(0,Math.min(ty,WORLD_H*TILE-384));
  camera.targetX=tx;camera.targetY=ty;
}

/* === NPC距離チェック === */
function checkNPCProximity(){
  activeNPC=null;
  for(const npc of NPCS){
    const dx=Math.abs(player.x-npc.x);
    const dy=Math.abs(player.y-npc.y);
    if(dx<=1 && dy<=1){
      activeNPC=npc;
      break;
    }
  }
  if(activeNPC){
    showNPCDialog(activeNPC);
  }else{
    dialogEl.style.display='none';
    messageIndex=0;
  }
}

/* === 吹き出し === */
function showNPCDialog(npc){
  const lines=npc.dialog;
  dialogEl.textContent=lines[messageIndex];
  const screenX=(npc.x*TILE-camera.x)+TILE/2;
  const screenY=(npc.y*TILE-camera.y)-10;
  dialogEl.style.left=screenX+'px';
  dialogEl.style.top=screenY+'px';
  dialogEl.style.display='block';
}

/* === 吹き出し操作 === */
dialogEl.addEventListener('touchstart',()=>{
  if(!activeNPC)return;
  cancelHold=false;
  holdTimer=setTimeout(()=>{
    cancelHold=true;
    dialogEl.style.display='none';
    messageIndex=0;
  },700); // 長押しでキャンセル
});

dialogEl.addEventListener('touchend',()=>{
  clearTimeout(holdTimer);
  if(cancelHold)return;
  if(!activeNPC)return;
  const lines=activeNPC.dialog;
  messageIndex++;
  if(messageIndex>=lines.length)messageIndex=0;
  showNPCDialog(activeNPC);
});

/* === 描画 === */
function render(){
  camera.x+=(camera.targetX-camera.x)*0.2;
  camera.y+=(camera.targetY-camera.y)*0.2;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // マップ
  for(let y=0;y<WORLD_H;y++)for(let x=0;x<WORLD_W;x++){
    const t=world[y][x];
    ctx.fillStyle=t===1?'#2b4f2b':t===2?'#c9a36e':t===3?'#7aa8c2':t===4?'#2a9':'#3a8a3a';
    ctx.fillRect(x*TILE-camera.x,y*TILE-camera.y,TILE,TILE);
  }

  // NPC
  for(const npc of NPCS){
    ctx.fillStyle=npc.color;
    ctx.fillRect(npc.x*TILE-camera.x+6,npc.y*TILE-camera.y+6,TILE-12,TILE-12);
  }

  // プレイヤー
  ctx.fillStyle='#66f';
  ctx.fillRect(player.px-camera.x+4,player.py-camera.y+4,TILE-8,TILE-8);
}

/* === メインループ === */
function gameLoop(){
  updateCameraTarget();
  checkNPCProximity();
  render();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* === スワイプ操作 === */
let startX=null,startY=null,lastMoveTime=0;
canvas.addEventListener('touchstart',e=>{
  const t=e.touches[0];startX=t.clientX;startY=t.clientY;
});
canvas.addEventListener('touchmove',e=>{
  if(!startX||!startY)return;
  const t=e.touches[0];const dx=t.clientX-startX,dy=t.clientY-startY;
  const now=performance.now();
  if(now-lastMoveTime<150)return;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>20)attemptMove('right');else if(dx<-20)attemptMove('left');
  }else{
    if(dy>20)attemptMove('down');else if(dy<-20)attemptMove('up');
  }
  lastMoveTime=now;startX=t.clientX;startY=t.clientY;
});
canvas.addEventListener('touchend',()=>{startX=startY=null;});
</script>
</body>
</html>
